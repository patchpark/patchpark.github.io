---
title: 17822 원판돌리기 [java]
date: 2024-07-11 21:00 +09:00
categories: [알고리즘, 그리디.라인스위핑.투포인터]
---
# 문제 링크
[17822 원판돌리기](https://www.acmicpc.net/problem/17822)

# 접근 방법
주어진 것은 원판이나 결국 이차원 배열로 푸는 문제였다. 문제에서 주어진 대로 회전시켜주는 함수, 인접한 것이 같을 경우 제거 해주는 함수, 인접한 것이 없을 때에 수행할 함수 세가지로 구현하였다.

처음에는 인접한 같은 값을 제거 하는 함수에서 추가적인 배열 사용 없이 풀이하려 했으나, 이러한 경우에는 값이 먼저 바뀌어 인접하고 값이 같아도 제거되지 않는 경우가 발생하여, 새로운 배열을 선언하여 저장한 뒤 한번에 업데이트 하는 식으로 구현 하였다.

# 문제 풀이
```java
import java.util.ArrayList;
import java.util.Scanner;

public class Main {

	static int N, M;
	static int[][] map;
	static int[] moveX = { -1, 0, 1, 0 }; // 위 오른쪽 아래 왼쪽
	static int[] moveY = { 0, 1, 0, -1 };
	static ArrayList<Cctv> cctv = new ArrayList<Cctv>();
	static int answer = 64;

	static class Cctv {
		int x, y, n;

		public Cctv(int x, int y, int n) {
			this.x = x;
			this.y = y;
			this.n = n;
		}
	}

	public static void main(String[] args) {

		Scanner sc = new Scanner(System.in);

		N = sc.nextInt();
		M = sc.nextInt();

		map = new int[N][M];

		for (int i = 0; i < N; i++) {
			for (int j = 0; j < M; j++) {
				map[i][j] = sc.nextInt();
			}
		}

		for (int i = 0; i < N; i++) {
			for (int j = 0; j < M; j++) {
				if (map[i][j] > 0 && map[i][j] < 6) {
					cctv.add(new Cctv(i, j, map[i][j]));
				}
			}
		}

		find(0);

		System.out.println(answer);
	}

	public static void find(int count) {
		if (count == cctv.size()) {
			int temp = 0;
			for (int i = 0; i < N; i++) {
				for (int j = 0; j < M; j++) {
					if (map[i][j] == 0) {
						temp++;
					}
				}
			}

			answer = Math.min(answer, temp);
			return;
		}

		Cctv current = cctv.get(count);
		int[][] backUp = new int[N][M];
		copyMap(map, backUp);

		for (int i = 0; i < 4; i++) {
			chooseDirection(current.x, current.y, current.n, i);
			find(count + 1);
			copyMap(backUp, map);
		}
	}

	public static void copyMap(int[][] source, int[][] destination) {
		for (int i = 0; i < N; i++) {
			for (int j = 0; j < M; j++) {
				destination[i][j] = source[i][j];
			}
		}
	}

	public static void chooseDirection(int x, int y, int type, int direction) {
		switch (type) {
		case 1:
			work(x, y, direction);
			break;
		case 2:
			work(x, y, direction);
			work(x, y, (direction + 2) % 4);
			break;
		case 3:
			work(x, y, direction);
			work(x, y, (direction + 1) % 4);
			break;
		case 4:
			work(x, y, direction);
			work(x, y, (direction + 1) % 4);
			work(x, y, (direction + 2) % 4);
			break;
		case 5:
			for (int i = 0; i < 4; i++) {
				work(x, y, i);
			}
			break;
		}
	}

	public static void work(int x, int y, int direction) {
		int newX = x + moveX[direction];
		int newY = y + moveY[direction];

		if (newX < 0 || newY < 0 || newX >= N || newY >= M || map[newX][newY] == 6)
			return;

		if (map[newX][newY] == 0)
			map[newX][newY] = -1;

		work(newX, newY, direction);
	}

}


```
